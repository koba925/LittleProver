# 定理証明手習い (31)

> 次のフォーカスで`ctx?/t`を使えるでしょうか？
> はい、オレンジ色で示したぜんていがあるので使えます。あとで`ctx?/t`の証明はしないといけませんけどね。

あとでいいんだっけ？

```
(J-Bob/prove (defun.ctx?)
  '(((dethm ctx?/t (x)
         (if (ctx? x)
             (equal (ctx? x) 't)
             't))
     nil)
    ((dethm ctx?/sub (x y)
     :
``` 

これでちゃんと結果出るんだな
そういえば下の方から証明していくって話だったかそうかそういう意味になるのか
じゃあ上に無茶な定理とか書いても使えちゃうんだ

```
> (J-Bob/prove (my/prelude)
    '(((dethm mucha (a b)
         (equal a b))
       nil)
      ((dethm kucha ()
         (equal 't 'nil))
       nil
       ((1) (mucha 't 'nil)))))
(equal 'nil 'nil)
```

ほんとだ
でもやっぱり定理って証明してから使うものじゃないのかなあ
どうしてこういう仕様になってるんだろう？

まあもう証明したし

あとは長いけど`ctx?/t`の証明でだいたい感じはつかめてるので
流れに沿って進む
`ctx?/t`の証明もどうやら思った通りの流れだった模様
(細部まで細かく答え合わせする気力なし)

どこで関数を展開するかはちょっと悩む
行き詰ったくらいでやるのがいい気はする

# 定理証明手習い (32) 8 これがルールです

まず`member?`と`set?`の定義が出てきますがこれは下準備
いままでどおりにやるだけです

`(if (natp (size ys)) ...)`は定理にしておいてみよう
こうかな
```
(defun dethm.if/natp/size ()
  (J-Bob/define (dethm.ctx?/sub)
    '(((dethm if/natp/size (x a b)
         (equal (if (natp (size x)) a b) a))
       nil
       ((1 Q) (natp/size x))
       ((1) (if-true a b))
       (() (equal-same a))))))
```

ところで`-`と`/`の使い分けがいまひとつピンときてないので名前は変かもしれない
これで

```
(J-Bob/prove (dethm.if/natp/size)
  '(((defun member? (x ys)
       (if (atom ys)
           'nil
           (if (equal x (car ys))
               't
               (member? x (cdr ys)))))
     (size ys)
     (() (if/natp/size ys
                       (if (atom ys)
                           't
                           (if (equal x (car ys))
                               't
                               (< (size (cdr ys)) (size ys))))
                       'nil)))))
```

うんできてるできてる
なんと2行が1行に!

ほかには何かパターン出てこないかなあ

# 定理証明手習い (33) 全域性の主張の作り方

8章では全域性の主張の作り方をやるんでした

題材はこれ

```
(defun add-atoms (x ys)
  (if (atom x)
      (if (member? x ys)
          ys
          (cons x ys))
      (add-atoms (car x)
                 (add-atoms (cdr x) ys))))
```

再帰のところが少し変わった形になっていますが
尺度はいつもどおり`(size x)`で
`J-Bob/prove`に尺度を与えてやると普通に全域性の主張が出力されます

そこをあえて手作りしてやるのがこの章
証明自体は出てきませんし自分でやってもすぐ

まずこの再帰呼び出しについて考えます

```
(add-atoms (car x) (add-atoms (cdr x) ys))
```

この関数適用では`add-atoms`の定義における`x`を`(car x)`に
`ys`を`(add-atoms (cdr x) ys)`に置き換えています

これと同様な置き換えを、尺度である`(size x)`に対して行うと`(size (car x))`になります
これが`(add-atoms (car x) (add-atoms (cdr x) ys))`という関数適用に対する尺度だそうです

わかるようなわからないような？
じゃあ`(size x)`は何に対する尺度？

定義らしきものに戻ってみます

> **尺度**というのは、関数の定義と一緒に提示される式です。尺度の式では、それまでに定義済みの全域関数と、関数の定義に出てくる仮引数だけを参照して良いことになっています。尺度の式は、定義している関数が再帰的に呼び出されるたびに減少する自然数を返さなければなりません。

関数適用に対する尺度がなんなのかはかいてありませんがなんとなくそういう感じのものということで進みます

関数適用のたびに尺度（これは元の関数に対する尺度でしょうね）が減るという主張は
すなわち`(size (car x))`が`(size x)`よりも小さい、
すなわち`(< (size (car x)) (size x))`という主張になります

さらに、`(add-atoms (cdr x) ys)`も再帰的な関数適用です
同様に考えると、`(add-atoms (cdr x) ys)`に対する尺度は`(size (cdrx))`となり
適用時に尺度が減少すると言う主張は`(< (size (cdr x)) (size x))`となります

というところから逆算すると前半は
`(add-atoms (car x) (add-atoms (cdr x) ys))`という形を見て
あ、なんか二重に再帰してる、なんかやばそう、とか思わないで
単に`(add-atoms (cdr x) ys)`を単なる引数と見て扱う、ってことでいいみたいですね

合わせるとこうなります

```
(if (< (size (car x)) (size x))
    (< (size (cdr x)) (size x))
    'nil)
```

これは`(< (size (car x)) (size x))`と`(< (size (cdr x)) (size x))`の
両方が真であるときのみ真になる式で、つまりふたつの式のANDをとっています
式がふたつ以上になってもifをつなげていけばANDが取れます
難しそうな説明が書いてありますがつまりそういうことです

ANDのことを連言といいますが、そうやってつながっていくイメージから来てるのかなあ？

さて順番が逆転してる気がしますが元の定義は`(atom x)`かどうかで処理が分かれています
`(atom x)`の場合はどうなんでしょうか
こちらは再帰呼び出しがないので全域、ということで即`'t`でいいようです

ということで`(size x)`は常に減っていきそうな感じになりましたので
`(size x)`は自然数だよ、と言ってあげれば関数がいつかは値を返すと
無限下降法ですね

でも定義で尺度は自然数、って決めてるのに「もし尺度が自然数ならば」っていうのは
ちょっと不自然な気がするなあ
いや自然数っていうのは定義に含まれてるわけじゃないのか？

それに`(size x)`の減少がいつかは行き止まりにたどりつくといっても
たどりついたときにちゃんと値を返してくれるって言えるのかな？
この関数の場合だと`(size x)`がゼロになる＝`x`がアトム＝`'t`を返す、でいいわけだけど
っていうのは暗黙でセットになってるのかな？
それともそういうのまで含めて実際には尺度が減る一方＆尺度は自然数、でかならず値が返るもの？
よく考えればそうなってる気もしないではない

ところで尺度が`(size x)`だというのはどうやって決めるんでしょうか？
再帰呼び出しの引数に出てくる変数ってのはいいとして
じゃあ`ys`はどうして出てこないんでしょうか？
まあ見ればいらなさそうなのはわかりますが厳密に言うとどういうルール？

# 定理証明手習い (33) 全域性の主張の作り方2

っていう話を

> 関数 (defun *name* (*x1* ... *xn*) *body*) および尺度 *m* が与えられたら、 *body* の部分式に対して次のようにして主張を構成する。

とか言って難しく書いてあります
難しいので`add-atoms`を1字1句このとおりにやってみます

```
(defun add-atoms (x ys)
  (if (atom x)
    (if (member? x ys)
        ys
        (cons x ys))
    (add-atoms (car x)
               (add-atoms (cdr x) ys))))
```

*name* が`add-atoms`、
*x1* が`x`、
*x2* が`ys`、
*body* が

```
(if (atom x)
  (if (member? x ys)
      ys
      (cons x ys))
  (add-atoms (car x)
             (add-atoms (cdr x) ys)))
```

*m* が`(size x)`、となります

*body* は`(if Q A E)`の形をしてますからまずはこのルールから

> - Q、A、Eに対する主張が *Cq* 、 *Ca* 、 *Ce* であるとき、(if Q A E)であれば、 *Ca* および *Ce* が同じなら *Cq* と *Ca* の連言を主張とし、そうでなければ *Cq* と (if *Q* *Ca* *Ce*)の連言とする。

（これルール2と呼びますね）

しかしそのためにはQ、A、Eに対する主張を調べる必要があります
ここでは以下の通り

Qは`(atom x)`
Aは`(if (member? x ys) ys (cons x ys))`
Eは`(add-atoms (car x) (add-atoms (cdr x) ys))`

Qからいきますか
これは`(if Q A E)`の形ではないのでこのルールを適用します

> - それ以外の式 *E* については、 *E* に出てくる再帰的な関数適用(*name* *e1* ... *en*)を調べる。まず、尺度 *m* に出てくる *x1* を *e1* に、...、 *xn* を *en* に置き換えることで、再帰的な関数適用に対する尺度 *mr* を作る。 *E* についての主張は、 *E* に出てくる再帰的な関数適用のそれぞれについての(< *mr* *m*)の連言とする。

（ルール3）

ここの *E* は`(if Q A E)`のEとは別です

さてQには再帰的な関数適用がありません
再帰的な関数適用がない場合について書いてねーじゃねーか！とツッコミたくなりますが

> 式 *e1* 、...、* en* の **連言** とは、 *e1* , ...,  *en* のそれぞれが真でなければならないということ。
> - 0個の式の連言は、`'t`である。

って書いてありました スキはなかった
ということで *Cq* は`'t`

つぎA
これは`(if Q A E)`の形なので再帰的にルールを適用します
ここでは

Q `(member? x ys)`
A `ys`
E `(cons x ys)`

Qから考えると、これは関数適用だけど再帰的な関数適用ではないのでここでも *Cq* は`'t`ということでいいですよね？
`member?`の全域性はすでに証明済みって風に考えればいいのかな？

Aに関してはこのルールで

> - 変数及びクォートされたリテラルであれば、`'t`を主張とする。

（ルール1）

*Ca* も`'t`

*Ce* もはルール3から`'t`ですね

*Ca* と *Ce* が同じなので`(if (member? x ys) ys (cons x ys))`の主張は *Cq* と *Ca* の連言、
すなわち`(if 't 't 'nil)` = `'t`となります

えーと元の式に戻って
次はE:`(add-atoms (car x) (add-atoms (cdr x) ys))`を考えます
ルール3ですね

まずは関数適用`(add-atoms (car x) (add-atoms (cdr x) ys))`について考えます
尺度 *m*:`(size x)`に出てくる *x1*:`x`を *e1*:`(car x)`に、
*x2*:`ys`を *e2*:`(add-atoms (cdr x) ys))`に置き換えると
この関数適用に対する尺度 *mr*:`(size (car x))`が出てきます
*E* に出てくる再帰的な関数適用はもうひとつ`(add-atoms (cdr x) ys)`があります
こちらも同様にするとこちらの尺度 *mr* は`(size (cdr x))`となります

> *E* についての主張は、 *E* に出てくる再帰的な関数適用のそれぞれについての(< *mr* *m*)の連言とする。

`(< mr m)`はそれぞれ
`(< (size (car x)) (size x))`
`(< (size (cdr x)) (size x))`となり
*Ce* はそれらの連言で
`(if (< (size (car x)) (size x)) (< (size (cdr x)) (size x)) 'nil)`となります

いったん整理

*Cq*: `'t`
*Ca*: `'t`
*Ce*: `(if (< (size (car x)) (size x)) (< (size (cdr x)) (size x)) 'nil)`

ルール2の

> そうでなければ *Cq* と(if *Q Ca Ce*)の連言とする。

にしたがうと *body* に対する主張は

```
(if 't 
  (if (atom x) 
      't 
      (if (< (size (car x)) (size x)) 
          (< (size (cdr x)) (size x))
          'nil))
  'nil)
```

となります
最後に

> 関数 name の全域性についての主張は、 *(natp m)* と *body* に対する主張の連言になる。

にしたがって

```
(if (natp (size x))
  (if 't 
    (if (atom x) 
        't 
        (if (< (size (car x)) (size x)) 
            (< (size (cdr x)) (size x))
            'nil))
    'nil)
  'nil)
```

できあがり！

なんですけど`if-true`しておきますか

```
(if (natp (size x))
  (if (atom x) 
      't 
      (if (< (size (car x)) (size x)) 
          (< (size (cdr x)) (size x))
          'nil))
  'nil)
```

これで本と同じ形に

> おおざっぱに考えると
> (if (natp (size x)) ... 'nil)はオマジナイで
> あとは関数の形をもとにしつつ
> (car x)や(cdr x)を見かけたらsizeが小さくなっていくことを
> 確かめるって感じでしょうか
> (equal x '?)は全域だってわかってるから'tに変換するってことかな
> でも全域だからって(atom x)を'tに置き換えちゃうとこれは変
> 明確なルールにするとすればどうなるんでしょう？
> Q部はそのままとか？
> もうちょっと何かありそう
> Q部が再帰することもあるでしょうし
> その時は1段ifを増やしてsizeが減ってることを言うんでしょうか

ま、まあだいたいあってる（ことにする

# 定理証明手習い (33) 9 ルールを変えるには


